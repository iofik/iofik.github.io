<html>
<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/></head>
<body><pre>
Семинар 10.

1.	Транспортная сеть:
		- ориентированный граф G(V, E);
		- неотрицательная функция c(e) на рёбрах — пропускная способность;
		- две выделенные вершины: источник (s) и сток (t), такие, что любая вершина
		  лежит на каком-то пути из s в t.
	На несуществующих рёбрах пропускная способность полагается равной нулю.
	Поток — функция f: V × V → R со свойствами:
		- ограничение пропускной способности: f(u, v) ⩽ c(u, v);
		- антисимметричность: f(u, v) = -f(v, u);
		- сохранение потока: для любого u, сумма по v ∑f(u, v) = 0.
	Величина потока: |f| = ∑f(s, v).
	Максимальный поток: поток с максимальной величиной.
	Разрез: разбиение множества вершин V на два подмножества A и B, таких что
	s ∈ A, а t ∈ B. Пропускная способность разреза и поток через разрез —
	соответственно суммы ∑c(u, v) и ∑f(u, v), где (u, v) ∈ A × B.
	Минимальный разрез — разрез с минимальной пропускной способностью.
	Остаточная пропускная способность: c_f(u, v) = c(u, v) - f(u, v).
	Остаточная сеть: G(V, E_f), где E_f — множество рёбер с положительной
	остаточной пропускной способностью. Заметим, что в E_f могут появиться рёбра,
	которых не было в E.
	Увеличивающий путь — путь в остаточной сети из s в t.

2.	Свойства.
	Поток через любой разрез равен сумме потоков из источника.
	Сумма потоков из источника равна сумме потоков в сток.
	Максимальный поток положителен тогда и только тогда, когда есть путь из
	источника в сток по рёбрам с положительной пропускной способностью.
	Поток максимален тогда и только тогда, когда нет увеличивающего пути.
	Теорема Форда-Фалкерсона: величина максимального потока равна пропускной
	способности минимального разреза.

3.	Алгоритм Форда-Фалкерсона ищет максимальный поток в сети.
	В ходе алгоритма на каждом шаге ищется увеличивающий путь, а затем поток
	вдоль этого пути увеличивается на минимум из пропускных способностей рёбер,
	составляющих этот самый путь. Для этого алгоритм работает с остаточной сетью
	и поддерживает её в актуальном состоянии. Инициализация осуществляется нулевыми
	потоками и остаточной сетью, совпадающей с данной транспортной сетью.
	Так как на каждом шаге поток увеличивается на минимальную пропускную способность
	увеличивающего пути, то для целочисленных сетей (а так же, рациональных и прочих
	сводимых к целочисленным) алгоритм Форда-Фалкерсона гарантированно сойдётся за
	время O(E∙|f|): всего потребуется не более |f| итераций по O(E) каждая.
	Заметим, что для иррациональных сетей, алгоритм может работать бесконечно долго
	и сходиться к неправильному ответу.

4.	Алгоритм Эдмондса-Карпа — это алгоритм Форда-Фалкерсона, в котором в качестве
	увеличивающего пути каждый раз выбирается наикратчайший (в смысле количества
	рёбер) путь в остаточной сети. Оказывается, что в этом случае алгоритм работает
	за полиномиальное время: O(VE^2). На каждом шаге ищется кратчайший путь за O(E)
	(поиск в ширину), а всего шагов будет O(VE). Докажем это.

5.	Сначала докажем, что в ходе работы алгоритма ни одна вершина не приближается
	(в смысле расстояния — минимального количества рёбер в пути) к источнику s.
	Пусть на каком-то шаге вершина v приблизилась к s, причём, она стала ближайшей
	к s среди всех приблизившихся на этом шаге вершин. Рассмотрим кратчайший путь
	из s в v и предпоследнюю на этом пути вершину u. Тогда для расстояний до этих
	вершин из источника до шага (d) и после шага (d') можно записать следующие
	неравенства: d(v) > d'(v) = d'(u)+1, и, так как u не приблизиась: d'(u) ⩾ d(u).
	Откуда получаем: d(v) ⩾ d(u)+2. Это значит, что до шага ребра (u,v) не было,
	значит что оно появилось на этом шаге, и, следовательно в увеличивающем пути
	должно было быть ребро (v,u). А так как путь кратчайший, то d(u) = d(v)+1.
	Противоречие с предыдущими неравенствами.

6.	Теперь посчитаем, сколько раз ребро (u,v) может быть критическим, то есть
	быть на увеличивающем пути и иемть минимальную пропускную способность на нём.
	Пусть оно было критическим на итерациях i и j. Так как критическое ребро после
	итерации выкидывается из остаточной цепи, то должен быть шаг k: i < k < j, на
	котором это ребро добавилось обратно. Тогда можно записать цепочку неравенств:
		d_i(v) = d_i(u) + 1 ⩾ d_k(u) + 1 = d_k(v) + 2 ⩾ d_j(v) + 2.
	А так как d_i(v) принимает значения от 0 до V, то ребро (i,j) может стать
	критическим не более O(V) раз. То есть всего итераций у нас будет O(VE).
</pre>
<font size=2 face="Arial"><a href="index.html">&lt;&lt;</a></font>
</body>
</html>
